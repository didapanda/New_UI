'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Web3 = _interopDefault(require('web3'));

const NETWORKS = {
  1: {
    name: 'Eth - Main Net',
    unit: 'ETH',
    isTest: false,
    hasExplorer: true,
    defaultGasPrice: 1,
    explorer: {
      root: 'https://etherscan.io/',
      address: 'address/',
      tx: 'tx/'
    }
  },
  2: {
    name: 'Eth - Deprecated Morden test network',
    unit: 'ETH',
    isTest: true,
    hasExplorer: false
  },
  3: {
    name: 'Eth - Ropsten test network',
    unit: 'ETH',
    isTest: true,
    hasExplorer: true,
    defaultGasPrice: 1,
    explorer: {
      root: 'https://ropsten.etherscan.io/',
      address: 'address/',
      tx: 'tx/'
    }
  },
  4: {
    name: 'Eth - Rinkeby test network',
    unit: 'ETH',
    isTest: true,
    hasExplorer: false
  },
  5: {
    name: 'Eth - GÃ¶rli test network',
    unit: 'ETH',
    isTest: true,
    hasExplorer: true,
    defaultGasPrice: 1,
    explorer: {
      root: 'https://goerli.etherscan.io/',
      address: 'address/',
      tx: 'tx/'
    }
  },
  42: {
    name: 'Eth - Kovan test network',
    unit: 'ETH',
    isTest: true,
    hasExplorer: false
  },
  66: {
    name: 'Aldwych network',
    unit: 'ETH',
    isTest: true,
    hasExplorer: true,
    defaultGasPrice: 1,
    explorer: {
      root: 'https://explorer.aldwych.blaquetec.org/',
      address: 'account/',
      tx: 'tx/'
    }
  },
  77: {
    name: 'POA - Sokol test network',
    unit: 'SPOA',
    isTest: true,
    hasExplorer: true,
    defaultGasPrice: 1,
    explorer: {
      root: 'https://sokol-explorer.poa.network/',
      address: 'account/',
      tx: 'tx/'
    }
  },
  99: {
    name: 'POA - Main Net',
    unit: 'POA',
    isTest: false,
    hasExplorer: true,
    defaultGasPrice: 1,
    explorer: {
      root: 'https://sokol-explorer.poa.network/',
      address: 'account/',
      tx: 'tx/'
    }
  },
  100: {
    name: 'xDAI',
    unit: 'xDAI',
    isTest: false,
    hasExplorer: true,
    defaultGasPrice: 1,
    explorer: {
      root: 'https://blockscout.com/poa/xdai/',
      address: 'account/',
      tx: 'tx/'
    }
  },
  4447: {
    name: 'Eth - Truffle Develop Network',
    unit: 'ETH',
    isTest: true,
    hasExplorer: false
  },
  5777: {
    name: 'Eth - Ganache Blockchain',
    unit: 'ETH',
    isTest: true,
    hasExplorer: false
  }
};

const getNetwork = networkId => NETWORKS[networkId] ? NETWORKS[networkId] : {};

const explorer = networkId => (type, id) => {
  const explorer = getNetwork(networkId).explorer;
  if (!explorer || !explorer[type]) return null
  return `${explorer.root}${explorer[type]}${id}`
};

const Web3Watcher = () => {
  const $ = {
    injected: null,
    instance: null,
    accounts: [],
    networkId: null,
    walletType: null,
    state: {
      init: 0,
      update: 0,
      error: null,
      isConnected: false,
      events: false
    }
  };

  const eventHandler = {};

  let stateHook = state => { throw new Error('Web3Watcher stateHook not set') };

  $.setStateHook = fn => { stateHook = fn; };

  $.on = (event, fn) => { eventHandler[event] = fn; };

  const updateState = data => {
    $.state = { ...$.state, ...data, update: $.state.update + 1 };
    stateHook($.state);
  };

  const onAccountsChanged = accounts => {
    $.accounts = accounts;
    updateState({});
    typeof eventHandler.accountsChanged === 'function' && eventHandler.accountsChanged($);
  };

  const onNetworkChanged = networkId => {
    $.networkId = networkId;
    updateState({});
    typeof eventHandler.networkChanged === 'function' && eventHandler.networkChanged($);
  };

  $.init = async options => {
    if (window.ethereum) {
      try {
        $.injected = window.ethereum;
        if ($.injected.isMetaMask) {
          $.state = { ...$.state, events: true };
          window.ethereum.autoRefreshOnNetworkChange = false;
          window.ethereum.on('accountsChanged', onAccountsChanged);
          window.ethereum.on('networkChanged', onNetworkChanged);
        }
        $.accounts = await window.ethereum.enable();
        $.instance = new Web3(window.ethereum);
        $.networkId = window.ethereum.networkVersion;
        $.state = {
          ...$.state,
          isConnected: await $.instance.eth.net.isListening()
        };
        updateState({ init: $.state.init + 1 });
      } catch (error) {
        $.state = { ...$.state, error: error.message, isConnected: false };
        updateState({});
      }
    } else {
      try {
        if (window.web3.currentProvider) {
          $.injected = window.web3;
          $.instance = new Web3(window.web3.currentProvider);
        }
        updateState({ init: $.state.init + 1 });
      } catch (error) {
        $.state = { ...$.state, error: error.message, isConnected: false };
        updateState({});
      }
    }
    typeof eventHandler.connected === 'function' && $.state.isConnected && eventHandler.connected($);
    $.walletType = await $.getWalletType();
    if (!$.networkId) $.networkId = await $.getId();
    updateState({});
    return Promise.resolve($.state)
  };

  $.reset = () => {
  };

  $.getId = () =>
    new Promise((resolve, reject) => {
      if (!$.instance) return reject(new Error('not connected'))
      $.instance.eth.net.getId((err, networkId) => {
        if (err) {
          reject(err);
        } else {
          resolve(networkId);
        }
      });
    });

  $.getWalletType = () => new Promise((resolve, reject) => {
    if (!$.instance || !$.instance.currentProvider) return reject(new Error('can determine provider'))
    const provider = $.instance.currentProvider;
    // TODO find new heuristics
    if (provider.isNiftyWallet) {
      return resolve('Nifty')
    }
    if (provider.isMetaMask) {
      /* some fork of Metamask may identify as Metamask */
      return resolve('MetaMask (or compatible)')
    }
    if (provider.isTrust) {
      return resolve('Trust')
    }
    return resolve('unknown')
  });

  $.getAccounts = () => new Promise((resolve, reject) => {
    if (!$.instance) return reject(new Error('not connected'))
    $.instance.eth.getAccounts((err, accounts) => {
      if (err) {
        reject(err);
      } else {
        resolve(accounts);
      }
    });
  });

  $.getBalance = (account) => new Promise((resolve, reject) => {
    if (!$.instance) return reject(new Error('not connected'))
    $.instance.eth.getBalance(account, (err, result) => {
      if (err) {
        reject(err);
      } else {
        const balance = $.instance.utils.fromWei(result.toString(10), 'ether');
        resolve(balance);
      }
    });
  });

  return $
};

const isDebug = () => process.env.NODE_ENV !== 'production';

const web3Watcher = Web3Watcher(); // ADD potential option

class VueEthereum {
  constructor (options = {}) {
    const defaults = {
      accessorName: '$eth',
      // Vuex Options
      useVuex: false
      // vuexModuleName: 'eth',
      // Components
      // registerComponent: true,
      // Directives
      // registerDirective: true,
    };
    this.options = {
      ...defaults,
      ...options
    };
    this.initialized = false;
  }

  init (Vue, store) {
    if (isDebug() && !install.installed) {
      console.warn(
        // `[vue-ethereum] not installed. Make sure to call Vue.use(VueEthereum) before init root instance.`
      );
    }

    if (this.initialized) {
      return
    }

    if (this.options.registerComponent) ;

    if (this.options.useVuex) {
      // const { vuexModuleName } = this.options
      // if (!store) {
      throw new Error('[vue-ethereum] Vuex mode not yet available.')
      // }
    } else {
      this.stateHandler = new Vue({
        data () {
          return {
            web3State: null,
            accounts: [],
            networkId: null,
            walletType: null,
            balanceOf: {}
          }
        },
        computed: {
          error () {
            return this.web3State && this.web3State.error
          },
          isConnected () {
            return this.web3State && this.web3State.isConnected
          },
          networkName () {
            return getNetwork(this.networkId).name
          },
          isTestNetwork () {
            return getNetwork(this.networkId).isTest
          },
          balance () {
            return account => this.balanceOf[account]
          }
        },
        watch: {
          web3State: function (val, oldVal) {
            this.accounts = web3Watcher.accounts;
            this.networkId = web3Watcher.networkId;
            this.walletType = web3Watcher.walletType;
          }
        },
        methods: {
          saveWeb3State (s) {
            this.web3State = s;
          },
          async getBalance (account) {
            Vue.set(this.balanceOf, account, await web3Watcher.getBalance(account));
          }
        }
      });
    }

    this.initialized = true;
  }

  async connect () {
    web3Watcher.setStateHook(this.stateHandler.saveWeb3State);
    web3Watcher.init();
  }

  disconnect () {
    this.stateHandler.saveWeb3State(null);
    this.stateHandler.accounts = [];
    this.stateHandler.networkId = null;
    this.stateHandler.walletType = null;
  }

  /* helpers */

  get walletDetected () {
    return !!this.stateHandler.walletType
  }

  get walletType () {
    return this.stateHandler.walletType
  }

  get isConnected () {
    return this.stateHandler.isConnected
  }

  get error () {
    return this.stateHandler.error
  }

  get networkId () {
    return this.stateHandler.networkId
  }

  get networkName () {
    return this.stateHandler.networkName
  }

  get isTestNetwork () {
    return this.stateHandler.isTestNetwork
  }

  get accounts () {
    return this.stateHandler.accounts
  }

  get selectedAddress () {
    return this.stateHandler.accounts[0]
  }

  get web3 () {
    return web3Watcher.instance
  }

  on (event, fn) {
    web3Watcher.on(event, fn);
  }

  explorer (type, id) {
    return explorer(this.stateHandler.networkId)(type, id)
  }

  balance (account) {
    this.stateHandler.getBalance(account);
    return this.stateHandler.balance(account)
  }
}

function install (Vue) {
  if (install.installed && Vue) {
    if (isDebug()) {
      console.warn('[vue-ethereum] already installed. Vue.use(VueEthereum) should be called only once.');
    }
    return
  }

  Vue.mixin({
    /**
     * VueEthereum init hook, injected into each instances init hooks list.
     */
    beforeCreate () {
      const { eth, store, parent } = this.$options;

      let instance = null;
      if (eth) {
        instance = typeof eth === 'function' ? new eth() : eth; // eslint-disable-line new-cap
        // Inject store
        instance.init(Vue, store);
      } else if (parent && parent.__$ethInstance) {
        instance = parent.__$ethInstance;
        instance.init(Vue, parent.$store);
      }

      if (instance) {
        // Store helper for internal use
        this.__$ethInstance = instance;
        this[instance.options.accessorName] = instance;
      }
    }
  });

  install.installed = true;
}

VueEthereum.install = install;

exports.default = VueEthereum;
exports.install = install;
